# Canvas API升级与卡片优化方案

## 1. 需求分析
- 升级Canvas API到2D新版本
- 加大标题、主题、名言内容之间的间距
- 修改绘制出处的文本，去掉重复的"《菜根潭》"

## 2. 实现步骤

### 2.1 Canvas API 2D升级
- 修改wxml文件，添加canvas类型和id
- 修改js文件，使用新的Canvas API 2D创建上下文
- 更新绘制逻辑，去掉旧的draw()方法调用
- 更新画布转临时文件的方法

### 2.2 间距调整
- 加大标题到主题的间距
- 加大主题到名言内容的间距
- 调整名言内容到出处的间距

### 2.3 出处文本修改
- 修改绘制出处的代码，去掉重复的"《菜根潭》"
- 保留"——"前缀和source内容

## 3. 技术实现

### 3.1 修改index.wxml
```html
<!-- 分享图片画布（隐藏） -->
<canvas type="2d" id="shareCanvas" style="width: 750px; height: 1334px; position: absolute; left: -9999px; top: -9999px;"></canvas>
```

### 3.2 修改index.js中的generateShareImage方法
```javascript
/**
 * 生成分享图片
 */
generateShareImage(showDirectSave = false) {
  const quote = this.data.currentQuote;
  if (!quote) return;
  
  wx.showLoading({
    title: '生成图片中...',
  });
  
  // 小程序码File ID
  const qrcodeImageId = 'cloud://cloud1-4g76v9gbd3112c01.636c-cloud1-4g76v9gbd3112c01-1391701420/main/wyhd-minipro.png';
  
  // 下载小程序码
  wx.cloud.downloadFile({
    fileID: qrcodeImageId,
    success: (res) => {
      const qrcodePath = res.tempFilePath;
      
      // 使用Canvas API 2D
      const query = wx.createSelectorQuery();
      query.select('#shareCanvas')
        .fields({ node: true, size: true })
        .exec((res) => {
          const canvas = res[0].node;
          const ctx = canvas.getContext('2d');
          
          // 设置画布尺寸
          const dpr = wx.getSystemInfoSync().pixelRatio;
          canvas.width = 750 * dpr;
          canvas.height = 1334 * dpr;
          ctx.scale(dpr, dpr);
          
          const canvasWidth = 750;
          const canvasHeight = 1334;
          
          // 绘制渐变背景
          const gradient = ctx.createLinearGradient(0, 0, 0, canvasHeight);
          gradient.addColorStop(0, '#f8f0e3');
          gradient.addColorStop(1, '#e6d9c6');
          ctx.fillStyle = gradient;
          ctx.fillRect(0, 0, canvasWidth, canvasHeight);
          
          // 绘制装饰边框
          ctx.strokeStyle = '#d4af37';
          ctx.lineWidth = 8;
          ctx.strokeRect(20, 20, canvasWidth - 40, canvasHeight - 40);
          
          // 绘制装饰花纹
          ctx.fillStyle = '#d4af37';
          ctx.globalAlpha = 0.3;
          // 左上角花纹
          ctx.beginPath();
          ctx.arc(60, 60, 20, 0, 2 * Math.PI);
          ctx.fill();
          // 右上角花纹
          ctx.beginPath();
          ctx.arc(canvasWidth - 60, 60, 20, 0, 2 * Math.PI);
          ctx.fill();
          // 左下角花纹
          ctx.beginPath();
          ctx.arc(60, canvasHeight - 60, 20, 0, 2 * Math.PI);
          ctx.fill();
          // 右下角花纹
          ctx.beginPath();
          ctx.arc(canvasWidth - 60, canvasHeight - 60, 20, 0, 2 * Math.PI);
          ctx.fill();
          ctx.globalAlpha = 1;
          
          // 绘制标题
          ctx.fillStyle = '#8b4513';
          ctx.font = '52px sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText('菜根谭智慧', canvasWidth / 2, 140); // 加大间距
          
          // 绘制主题
          ctx.fillStyle = '#d4af37';
          ctx.font = '38px sans-serif';
          ctx.fillText(quote.theme, canvasWidth / 2, 230); // 加大间距
          
          // 绘制名言内容
          ctx.fillStyle = '#333333';
          ctx.font = '42px sans-serif';
          ctx.textAlign = 'left';
          
          const content = quote.quote;
          const lineHeight = 70;
          const maxWidth = 650;
          let startY = 320; // 加大间距
          let currentLine = '';
          
          for (let i = 0; i < content.length; i++) {
            const testLine = currentLine + content[i];
            const metrics = ctx.measureText(testLine);
            if (metrics.width > maxWidth && i > 0) {
              ctx.fillText(currentLine, (canvasWidth - maxWidth) / 2, startY);
              startY += lineHeight;
              currentLine = content[i];
            } else {
              currentLine = testLine;
            }
          }
          
          ctx.fillText(currentLine, (canvasWidth - maxWidth) / 2, startY);
          startY += lineHeight * 2;
          
          // 绘制出处（去掉重复的《菜根潭》）
          ctx.fillStyle = '#8b4513';
          ctx.font = '34px sans-serif';
          ctx.textAlign = 'right';
          ctx.fillText(`——${quote.source}`, canvasWidth - 60, startY);
          
          // 绘制底部装饰
          const bottomGradient = ctx.createLinearGradient(0, canvasHeight - 150, 0, canvasHeight);
          bottomGradient.addColorStop(0, 'rgba(212, 175, 55, 0.2)');
          bottomGradient.addColorStop(1, 'rgba(212, 175, 55, 0.4)');
          ctx.fillStyle = bottomGradient;
          ctx.fillRect(0, canvasHeight - 150, canvasWidth, 150);
          
          // 绘制小程序码
          const qrcodeSize = 75;
          const qrcodeX = 50;
          const qrcodeY = canvasHeight - 125;
          
          // 加载并绘制小程序码
          const img = canvas.createImage();
          img.onload = () => {
            ctx.drawImage(img, qrcodeX, qrcodeY, qrcodeSize, qrcodeSize);
            
            // 绘制小程序文字
            ctx.fillStyle = '#666666';
            ctx.font = '16px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('文益互动', qrcodeX + qrcodeSize + 15, qrcodeY + 30);
            ctx.fillText('长按识别二维码', qrcodeX + qrcodeSize + 15, qrcodeY + 55);
            
            // 保存图片到临时文件
            wx.canvasToTempFilePath({
              canvas: canvas,
              success: (res) => {
                wx.hideLoading();
                
                if (showDirectSave) {
                  // 直接保存到相册
                  this.saveImageToAlbum(res.tempFilePath, true);
                } else {
                  // 显示图片预览并提供保存选项
                  wx.showModal({
                    title: '分享图片已生成',
                    content: '是否保存图片到相册？',
                    success: (modalRes) => {
                      if (modalRes.confirm) {
                        // 保存图片到相册
                        this.saveImageToAlbum(res.tempFilePath);
                      }
                    }
                  });
                }
              },
              fail: (err) => {
                wx.hideLoading();
                wx.showToast({
                  title: '图片生成失败',
                  icon: 'none'
                });
              }
            });
          };
          img.src = qrcodePath;
        });
    },
    fail: (err) => {
      wx.hideLoading();
      wx.showToast({
        title: '小程序码下载失败',
        icon: 'none'
      });
    }
  });
}
```

## 4. 修改文件列表
- `index.wxml` - 更新canvas元素，添加type="2d"
- `index.js` - 升级Canvas API到2D新版本，调整间距，修改出处文本

## 5. 技术要点
- 使用新的Canvas API 2D创建上下文
- 处理设备像素比，确保图片清晰度
- 调整文本绘制位置，加大间距
- 修改出处文本，去掉重复内容
- 正确处理图片加载和绘制顺序

## 6. 预期效果
- Canvas API升级到2D新版本，提高绘制性能和兼容性
- 标题、主题、名言内容之间的间距更大，排版更美观
- 出处文本不再重复显示"《菜根潭》"，更加简洁

## 7. 注意事项
- 确保小程序基础库版本支持Canvas API 2D
- 测试不同设备上的显示效果
- 确保图片生成和保存功能正常工作