# 手机发热问题优化计划

## 1. 优化目标

解决手机发热问题，减少不必要的资源消耗，优化应用性能，提高用户体验。

## 2. 优化策略

### 高优先级（立即修改）

#### 1.1 梦境诗词游的定时器问题 ⚠️⚠️⚠️

**文件位置**：`/subgames/72DreamlandPoetryTravel/index.js`

**问题描述**：每2秒执行一次的定时器频繁更新DOM，`displayRandomCaves`方法执行大量计算。

**优化方案**：
- 将全局变量`gameData`和`currentDisplayedCaves`移至Page实例中
- 在页面隐藏/卸载时清理定时器
- 优化`displayRandomCaves`方法，减少重复计算
- 添加状态标记，避免不必要的重绘

**具体实现**：
```javascript
// 将全局变量移至Page实例中
Page({
  data: {
    gameData: {
      caves: [],
      poets: [],
      currentCave: null,
      currentPoem: null,
      hiddenChars: [],
      selectedPoetId: null,
      revealedHints: 0
    },
    currentDisplayedCaves: [],
    isCanvasDrawn: false
  },
  
  // 页面显示时启动定时器
  onShow() {
    if (!this.caveRotationTimer) {
      this.startCaveRotation();
    }
  },
  
  // 页面隐藏时清理定时器
  onHide() {
    this.stopCaveRotation();
  },
  
  // 页面卸载时清理定时器
  onUnload() {
    this.stopCaveRotation();
  },
  
  // 停止定时器
  stopCaveRotation() {
    if (this.caveRotationTimer) {
      clearInterval(this.caveRotationTimer);
      this.caveRotationTimer = null;
    }
  },
  
  // 优化displayRandomCaves方法
  displayRandomCaves() {
    // 缓存固定位置，避免每次都重新计算
    if (!this.cavePositions) {
      // 预计算位置网格
      this.cavePositions = [
        { x: 20, y: 20 },
        { x: 50, y: 20 },
        { x: 80, y: 20 },
        { x: 20, y: 50 },
        { x: 50, y: 50 }
      ];
    }
    
    // 使用缓存的位置，只随机选择
    // ... 优化后的代码 ...
  }
});
```

### 中优先级

#### 2.1 五行奥秘页面频繁的Canvas重绘 ⚠️⚠️

**文件位置**：`/subgames/WuxingMysteries/pages/main/index.js`

**问题描述**：页面在多个生命周期钩子中都调用了Canvas绘制，每次Tab切换都会执行完整的Canvas重绘。

**优化方案**：
- 添加状态标记，避免不必要的重绘
- 减少定时器延迟，优化绘制时机
- 优化Canvas绘制，使用组件实例指定Canvas上下文

**具体实现**：
```javascript
Page({
  data: {
    // 添加Canvas绘制状态标记
    isCanvasDrawn: {
      wuxing: false,
      wufang: false,
      wuse: false,
      wuzang: false,
      wuwei: false
    }
  },
  
  // 修改onShow方法，避免不必要的重绘
  onShow() {
    const currentTab = this.data.currentTab;
    if (!this.data.isCanvasDrawn[currentTab]) {
      setTimeout(() => {
        this.drawCurrentTabCanvas();
        // 标记为已绘制
        const updatedCanvasState = { ...this.data.isCanvasDrawn };
        updatedCanvasState[currentTab] = true;
        this.setData({ isCanvasDrawn: updatedCanvasState });
      }, 100);
    }
  },
  
  // 修改onTabChange方法，避免不必要的重绘
  onTabChange(e) {
    // ... 原代码 ...
    this.setData({ 
      // ... 原代码 ...
      isCanvasDrawn: {
        // 重置所有绘制状态
        wuxing: false,
        wufang: false,
        wuse: false,
        wuzang: false,
        wuwei: false
      }
    }, () => {
      setTimeout(() => {
        this.drawCurrentTabCanvas();
        // 标记当前Tab为已绘制
        const updatedCanvasState = { ...this.data.isCanvasDrawn };
        updatedCanvasState[tabId] = true;
        this.setData({ isCanvasDrawn: updatedCanvasState });
      }, 200);
    });
  }
});
```

### 低优先级

#### 3.1 星宿配对页面的setTimeout未清理 ⚠️

**文件位置**：`/subgames/28Stars/pages/star-matching/star-matching.js`

**问题描述**：在`checkMatch`函数中使用了2个setTimeout定时器，页面卸载时没有被清理。

**优化方案**：
- 添加定时器ID数组，保存所有定时器ID
- 在页面卸载时清理所有定时器

**具体实现**：
```javascript
Page({
  data: {
    // ... 原数据 ...
  },
  
  // 添加定时器ID数组
  matchTimers: [],
  
  // 检查配对
  checkMatch() {
    // ... 原代码 ...
    
    if (isMatch) {
      // ... 原代码 ...
      
      // 保存定时器ID
      const timerId = setTimeout(() => {
        this.setData({ currentMatch: null });
      }, 2000);
      this.matchTimers.push(timerId);
    } else {
      // ... 原代码 ...
      
      // 保存定时器ID
      const timerId = setTimeout(() => {
        // ... 原代码 ...
      }, 2000);
      this.matchTimers.push(timerId);
    }
  },
  
  // 页面卸载时清理所有定时器
  onUnload() {
    this.matchTimers.forEach(timer => clearTimeout(timer));
    this.matchTimers = [];
  }
});
```

#### 3.2 全局变量导致的内存泄漏风险 ⚠️

**问题描述**：多处使用全局变量存储页面状态，可能导致内存无法回收。

**优化方案**：
- 将全局变量转换为页面实例数据
- 在页面卸载时清理事件监听器和定时器

**具体实现**：
```javascript
// 将全局变量移入Page实例中
Page({
  data: {
    // 页面状态数据
  },
  
  // 页面卸载时清理资源
  onUnload() {
    // 清理定时器
    // 清理事件监听器
    // 清空大型数据结构
  }
});
```

## 3. 优化优先级

1. **高优先级**：梦境诗词游的定时器问题
2. **中优先级**：五行奥秘页面的Canvas重绘优化
3. **低优先级**：星宿配对页面的setTimeout清理和全局变量优化

## 4. 测试验证

- 修改后在真实设备上测试，确认发热问题是否缓解
- 使用微信开发者工具的性能监控功能，检查CPU和内存使用情况
- 测试页面切换、交互操作等场景，确保功能正常

## 5. 预期效果

- 减少不必要的CPU消耗，降低手机发热
- 优化内存使用，减少内存泄漏风险
- 提高页面响应速度，提升用户体验
- 增强应用稳定性，减少崩溃风险

## 6. 实施时间

- 预计总耗时：1-2小时
- 高优先级优化：30分钟
- 中优先级优化：45分钟
- 低优先级优化：30分钟
- 测试验证：15分钟

## 7. 额外建议

1. **性能监控**：添加性能监控代码，记录CPU和内存使用情况
2. **懒加载**：对大型数据文件实现懒加载
3. **代码拆分**：将复杂的绘制逻辑拆分为更小的函数，便于性能分析
4. **定期优化**：定期检查应用性能，及时发现并解决资源消耗问题

通过以上优化计划，我们可以有效解决手机发热问题，提升应用性能和用户体验。