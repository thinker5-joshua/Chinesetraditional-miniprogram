# 菜根谭随机翻页实现方案

## 1. 问题分析
- 当前菜根谭摘录程序进入时显示随机名言，但前后翻页是顺序的
- 用户希望前后翻页也不是顺序的，而是按照一个随机序列展现

## 2. 解决方案
- 构建一个包含所有名言索引的随机序列，每个索引只出现一次
- 翻页时按照这个随机序列的顺序展现名言
- 进入程序时从随机序列的起始位置或随机位置开始显示

## 3. 实现步骤
1. 在data中添加randomSequence数组，用于存储随机序列
2. 在initApp()方法中生成随机序列
3. 修改showQuote()方法，使其基于randomSequence获取名言
4. 修改showPreviousQuote()和showNextQuote()方法，基于randomSequence的索引翻页
5. 修改showRandomQuote()方法，在randomSequence中随机选择位置

## 4. 代码修改
- 修改index.js，添加随机序列生成逻辑
- 修改翻页逻辑，基于随机序列翻页

## 5. 预期效果
- 进入程序时显示随机名言
- 前后翻页时按照随机序列展现，不是顺序的
- 每次进入程序都会生成新的随机序列

## 6. 技术要点
- 使用Fisher-Yates洗牌算法生成随机序列
- 保持randomSequence的完整性，每个索引只出现一次
- 确保翻页逻辑正确处理边界情况

## 7. 修改文件列表
- `index.js` - 逻辑修改

## 8. 实现代码示例
```javascript
// 生成随机序列
shuffleArray(array) {
  const newArray = [...array];
  for (let i = newArray.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
  }
  return newArray;
}

// 初始化随机序列
initApp() {
  // 加载名言数据
  const quotes = data.quotes;
  // 生成随机序列
  const randomSequence = this.shuffleArray(Array.from({ length: quotes.length }, (_, i) => i));
  this.setData({
    quotes: quotes,
    randomSequence: randomSequence
  });
  // 显示随机序列的第一个名言
  this.showQuote(0);
  // 减少加载时间，提升用户体验
  setTimeout(() => {
    this.setData({ isLoading: false });
  }, 600);
}

// 显示指定索引的名言
showQuote(sequenceIndex) {
  const quotes = this.data.quotes;
  const randomSequence = this.data.randomSequence;
  if (!quotes || !randomSequence || sequenceIndex < 0 || sequenceIndex >= randomSequence.length) return;
  
  const quoteIndex = randomSequence[sequenceIndex];
  const currentQuote = quotes[quoteIndex];
  this.setData({
    currentIndex: sequenceIndex,
    currentQuote: currentQuote,
    isOriginalVisible: false,
    showOriginalDetail: false
  });
}
```