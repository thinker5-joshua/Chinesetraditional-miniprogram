## 云存储图片处理方案优化（无本地备选版）

### 问题分析

根据错误日志和用户反馈，之前使用 `getTempFileURL` 获取临时URL的方式出现了 `Cannot read property 'stat' of undefined` 错误。用户建议不要使用临时URL模式，而是直接获取云存储图像文件。同时，用户提醒后续会删除 `images` 目录下的图像文件，程序中请不要使用本地图片。

### 优化方案

1. **重新设计云存储工具类**
   - 使用 `wx.cloud.downloadFile` 替代 `getTempFileURL`
   - 实现本地文件缓存机制，完全依赖云存储
   - 提供统一的图片加载接口
   - 支持预加载和缓存管理
   - 移除所有本地图片备选方案

2. **核心功能实现**
   - **缓存索引管理**：使用本地存储记录每个云文件ID对应的本地路径和过期时间
   - **文件下载**：使用 `wx.cloud.downloadFile` 下载云存储图片
   - **缓存检查**：检查缓存是否存在、是否过期、文件是否存在
   - **文件操作**：使用 `wx.getFileSystemManager` 进行文件复制、删除、检查等操作
   - **统一接口**：提供 `getImage` 接口，支持云文件获取和缓存

3. **代码实现**

```javascript
// utils/cloudStorage.js
// 云存储图片处理工具类

const cloudStorage = {
  // 云存储文件配置
  cloudFiles: {
    'official-account-qr.png': 'cloud://cloud1-4g76v9gbd3112c01.636c-cloud1-4g76v9gbd3112c01-1391701420/main/official-account-qr.png',
    'wyhd-share-default.png': 'cloud://cloud1-4g76v9gbd3112c01.636c-cloud1-4g76v9gbd3112c01-1391701420/main/wyhd-share-default.png'
  },

  // 计算字符串的简单哈希值，用于生成缓存文件名
  getHash(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash;
    }
    return Math.abs(hash).toString(16);
  },
  
  // 从缓存获取图片路径
  getImageFromCache(fileID) {
    try {
      const cacheIndex = wx.getStorageSync('cloudStorageCacheIndex') || {};
      const cacheInfo = cacheIndex[fileID];
      
      if (cacheInfo) {
        const { localPath, expireTime } = cacheInfo;
        const now = Date.now();
        
        // 检查缓存是否过期（7天过期）
        if (now < expireTime) {
          // 检查文件是否存在
          const fs = wx.getFileSystemManager();
          try {
            fs.accessSync(localPath);
            return localPath;
          } catch (e) {
            // 文件不存在，删除缓存索引
            delete cacheIndex[fileID];
            wx.setStorageSync('cloudStorageCacheIndex', cacheIndex);
            return null;
          }
        } else {
          // 缓存过期，删除缓存索引和文件
          delete cacheIndex[fileID];
          wx.setStorageSync('cloudStorageCacheIndex', cacheIndex);
          try {
            const fs = wx.getFileSystemManager();
            fs.unlinkSync(localPath);
          } catch (e) {
            // 文件不存在，忽略
          }
          return null;
        }
      }
      return null;
    } catch (e) {
      console.error('获取缓存图片失败', e);
      return null;
    }
  },
  
  // 将图片保存到缓存
  saveImageToCache(fileID, tempFilePath) {
    try {
      const hash = this.getHash(fileID);
      // 根据文件扩展名设置本地文件名
      const ext = fileID.split('.').pop() || 'png';
      const localPath = `${wx.env.USER_DATA_PATH}/cloud-${hash}.${ext}`;
      
      // 复制文件到本地缓存目录
      const fs = wx.getFileSystemManager();
      fs.copyFileSync(tempFilePath, localPath);
      
      // 更新缓存索引
      const cacheIndex = wx.getStorageSync('cloudStorageCacheIndex') || {};
      const expireTime = Date.now() + 7 * 24 * 60 * 60 * 1000; // 7天过期
      cacheIndex[fileID] = {
        localPath,
        expireTime,
        lastUsed: Date.now()
      };
      wx.setStorageSync('cloudStorageCacheIndex', cacheIndex);
      
      return localPath;
    } catch (e) {
      console.error('保存图片到缓存失败', e);
      return null;
    }
  },
  
  // 下载图片（结合缓存机制）
  downloadImage(fileID) {
    return new Promise((resolve, reject) => {
      // 先检查缓存
      const cachedPath = this.getImageFromCache(fileID);
      if (cachedPath) {
        console.log('使用缓存图片:', fileID);
        resolve(cachedPath);
        return;
      }
      
      // 缓存不存在，下载图片
      console.log('下载图片:', fileID);
      wx.cloud.downloadFile({
        fileID,
        success: (res) => {
          // 保存到缓存
          const localPath = this.saveImageToCache(fileID, res.tempFilePath);
          resolve(localPath || res.tempFilePath);
        },
        fail: (err) => {
          console.error('下载图片失败', err);
          reject(err);
        }
      });
    });
  },
  
  // 统一的图片加载接口
  // 支持云文件ID或文件名
  getImage(fileName) {
    return new Promise((resolve, reject) => {
      if (!fileName) {
        reject(new Error('图片文件名不能为空'));
        return;
      }
      
      // 如果fileName已经是完整的云文件ID，直接使用
      if (fileName.startsWith('cloud://')) {
        this.downloadImage(fileName)
          .then(resolve)
          .catch(reject);
        return;
      }
      
      // 如果是配置的文件名，获取对应的云文件ID
      const fileID = this.cloudFiles[fileName];
      if (!fileID) {
        reject(new Error(`File ${fileName} not configured in cloudFiles`));
        return;
      }
      
      // 使用缓存机制下载文件
      this.downloadImage(fileID)
        .then(resolve)
        .catch(reject);
    });
  },
  
  // 预加载多张图片到缓存
  preloadImages(fileNames) {
    const promises = fileNames.map(fileName => {
      return this.getImage(fileName).catch(error => {
        console.error(`预加载图片 ${fileName} 失败:`, error);
      });
    });
    return Promise.all(promises);
  },
  
  // 清理过期缓存
  clearExpiredCache() {
    try {
      const cacheIndex = wx.getStorageSync('cloudStorageCacheIndex') || {};
      const now = Date.now();
      const fs = wx.getFileSystemManager();
      let deletedCount = 0;
      
      // 遍历缓存索引，删除过期缓存
      for (const fileID in cacheIndex) {
        const { localPath, expireTime } = cacheIndex[fileID];
        if (now > expireTime) {
          // 删除文件
          try {
            fs.unlinkSync(localPath);
            deletedCount++;
          } catch (e) {
            // 文件不存在，忽略
          }
          // 删除缓存索引
          delete cacheIndex[fileID];
        }
      }
      
      // 更新缓存索引
      wx.setStorageSync('cloudStorageCacheIndex', cacheIndex);
      
      if (deletedCount > 0) {
        console.log(`清理了 ${deletedCount} 个过期缓存`);
      }
      
      return deletedCount;
    } catch (e) {
      console.error('清理过期缓存失败', e);
      return 0;
    }
  }
};

export default cloudStorage;
```

### 实施步骤

1. **替换云存储工具类**：将原有的 `cloudStorage.js` 替换为新的实现
2. **更新调用代码**：
   - 将所有 `getCloudImageUrl` 调用改为 `cloudStorage.getImage`
   - 更新 `app.js` 中的预加载调用
   - 确保所有调用处都不再引用本地图片路径
3. **测试验证**：测试图片加载功能，包括：
   - 首次加载（从云存储下载）
   - 二次加载（从缓存获取）
   - 缓存过期情况（重新下载）
   - 不同文件名的处理
4. **清理旧缓存**：清理之前使用临时URL模式的旧缓存

### 预期效果

1. **提高可靠性**：使用 `wx.cloud.downloadFile` 直接下载到本地，避免临时URL模式的问题
2. **提升加载速度**：本地缓存机制，二次加载速度更快
3. **完全云存储依赖**：不再使用本地图片作为备选，符合用户后续删除images目录的要求
4. **统一管理**：提供统一的图片加载接口，便于维护和扩展
5. **缓存可控**：支持缓存清理和预加载，提高系统资源利用率

### 风险评估

1. **文件系统依赖**：依赖小程序文件系统API，需要确保小程序基础库版本支持
2. **存储空间占用**：会占用本地存储空间，需要定期清理过期缓存
3. **兼容性**：需要确保所有调用处都能正确适配新的接口
4. **下载失败处理**：需要确保下载失败时能提供适当的错误反馈

### 兼容性考虑

1. **基础库版本**：确保小程序基础库版本支持 `wx.cloud.downloadFile` 和 `wx.getFileSystemManager`
2. **向后兼容**：保持功能的一致性，便于现有代码迁移
3. **错误处理**：增强错误处理机制，确保在各种异常情况下都能正常工作
4. **接口设计**：提供简单易用的接口，降低调用复杂度

### 调用示例

```javascript
// 在页面中使用
import cloudStorage from '../../utils/cloudStorage';

Page({
  data: {
    officialAccountQrUrl: ''
  },
  onLoad() {
    // 获取公众号二维码
    cloudStorage.getImage('official-account-qr.png')
      .then(url => {
        this.setData({
          officialAccountQrUrl: url
        });
      })
      .catch(error => {
        console.error('获取二维码失败:', error);
      });
  }
});
```

### 预加载配置

```javascript
// 在app.js中预加载
import cloudStorage from './utils/cloudStorage';

App({
  onLaunch: function() {
    // 初始化云开发
    wx.cloud.init({
      env: 'cloud1-4g76v9gbd3112c01',
      traceUser: true,
    });
    
    // 预加载常用云存储图片
    cloudStorage.preloadImages(['official-account-qr.png', 'wyhd-share-default.png']);
  }
});
```